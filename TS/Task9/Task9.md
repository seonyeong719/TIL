# 💙 Enum과 as const의 차이? import type을 해야하는 이유?

## 1. enum과 as const의 차이는 무엇일까? (트리쉐이킹과 번들 사이즈 관점에서 알아보기)

- Typescript에서 가독성을 높이기 위한 일환으로 서로 연관된 상수들을 하나의 namespace에 묶어 관리할 때, **enum**키워드를 사용해 Enum type을 선언하거나 객체 리터럴에 **as const**라는 type assertion을 사용한다.

```
두 경우 모두 IDE의 자동완성 기능을 활용할 수 있고, 객체의 프로퍼티들이 모두 readonly로 다뤄지기 때문에 변경의 우려도 없다.
```

  <br/>
  <br/>

### 애초에 목적이 다름

- **enum** : enum은 다른 언어의 Enumeration 문법처럼 서로 연관된 상수들을 하나의 namespace로 묶어 추상화 시키기 위해 도입된 것이다. <br/>
  👉🏻 이를 통해 코드만 보더라도 의도를 명확히 알 수 있어 가독성을 높일 수 있음

- **as const** : as const는 type assertion의 한 종류로써 리터럴 타입의 추론 범위를 줄이고 값의 재할당을 막기위한 목적으로 만들어졌다.

<br/>
<br/>

### Tree-shaking이란?

- Tree-shaking이란 간단하게 말해 **사용하지 않는 코드를 삭제하는 기능**을 말한다. <br/>
  나무를 흔들면 죽은 잎사귀들이 떨어지는 모습에 착안해 Tree-shaking이라고 부른다. <br/>Tree-shaking을 통해 export했지만 아무 데서도 import하지 않은 모듈이나 사용하지 않는 코드를 삭제해서 번들 크기를 줄여 페이지가 표시되는 시간을 단축할 수 있다.

<br/>
<br/>

### 번들 사이즈 및 트리쉐이킹 관점

> #### enum

- enum은 런타임에 실제 객체를 생성하며 번들 사이즈에 영향을 미칠 수 있다. 각 열거형 멤버는 번들에 포함되므로 모든 멤버를 포함한 크기가 번들에 추가된다.<br/> 👉🏻 따라서 enum을 사용하면 번들 사이즈가 증가할 수 있다.<br/>❗️ 또한 enum은 동적인 방식으로 열거형 멤버에 접근하는 것을 허용하므로 트리쉐이킹을 어렵게 만들 수 있다.

> #### as const

- as const를 사용하면 변수나 상수를 리터럴 타입으로 고정시키며, 런타임에 별도의 객체 생성 없이 리터럴 값을 사용한다.<br/>
  👉🏻 이로 인해 번들 사이즈가 작아지며, 트리쉐이킹에 도움을 준다.<br/>❗️ 또한, as const를 사용하면 열거형처럼 동적인 방식으로 값에 접근하는 것을 제한할 수 있다.

<br/>

```
🖐🏻 따라서 번들 사이즈와 트리쉐이킹 관점에서는 as const가 일반적으로 더 효율적이며, enum을 사용할 때는 번들 사이즈가 증가하고 트리쉐이킹이 어려워질 수 있음을 고려해야 한다.
```

<br/>
<br/>

## 2. enum은 그렇다면 쓰지 않는 것이 좋을까?

- enum은 열거형 멤버에 대한 자동 완성 및 타입 안전성을 제공함으로써 개발자가 오타로 인한 오류를 줄일 수 있게 해주며, 값들을 그룹화 하여 이름을 부여할 수 있으므로 코드의 가독성을 향상시킬수 있다.

<br/>

```
❗️하지만, enum은 번들 크기에 영향을 미치며, 상수의 모든 멤버가 번들에 포함이 될 수 있기 때문에 번들 크기가 커질 수 있다. 또한, 동적인 방식으로 열거형 멤버에 접근하는 것을 허용하므로  트리쉐이킹을 어렵게 만들 수 있다는 점에서 사용을 지양하는편이 좋은것 같다.
```

<br/>
<br/>

## 3. export한 type을 받을 때 import type을 해야하는 이유는 무엇일까?

> ### import type이란?

```tsx
// types.ts
export type TestType = { x: number };

// main.ts
import { TestType } from "./types"; // 타입과 값(타입 선언과 구현)을 모두 가져옴
const testValue: TestType = { x: 1 };

// other.ts
import type { TestType } from "./types"; // 타입만 가져옴
const testVal: TestType = { x: 2 }; // 값은 가져오지 않음
```

- 여기서 중요한 점은 interface는 Type-only export를 사용할 수가 없다❌는 점이다. <br/>
  오직 type alias를 사용했을 때만 Type-only export를 사용할 수가 있다.

<br/>
<br/>

> ### import type의 장점

1. **코드 가독성 향상** : TypeScript에서는 일반적으로 코드를 작성할 때 모듈에서 사용되는 모든 타입을 불러오기 위해 import 구문을 사용한다. 그러나 이러한 방식은 코드가 길어지고 가독성이 떨어질 수 있다.<br/> 👉🏻 타입만을 import하는 경우, 코드의 가독성이 향상되고 코드량이 줄어들어 유지보수가 용이해진다.

2. **불필요한 모듈 로딩 방지** : 전체 모듈을 import하는 경우, 애플리케이션이 로드될 때 불필요한 모듈도 함께 로딩되어 성능 저하를 초래할 수 있다.<br/>👉🏻 반면, 타입만을 import하는 경우, 필요한 타입만을 로드하여 성능 개선에 도움을 줄 수 있다.

3. **컴파일 속도 향상** : 타입만을 import하는 경우, 컴파일러가 불필요한 코드를 처리하지 않아 컴파일 속도가 빨라진다.

4. **타입 안정성** : 타입만을 import하는 경우, 타입 호환성 검사를 보다 엄격하게 수행할 수 있어 타입 안정성을 보장할 수 있다.

<br/>

```
🖐🏻 Type-only import/export는 코드의 가독성과 유지보수성, 성능, 타입 안정성에 매우 유용한 기능이다. 그러나 이를 사용할 때 주의해야 할 점이 있으며, 이를 고려하여 적절히 활용해야 한다.
```

<br/>
<br/>
<br/>
<br/>

참고 <br/>
https://kagrin97-blog.vercel.app/types/TypeOnly-Import,Export
